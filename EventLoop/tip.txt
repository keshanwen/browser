1. 进程和线程

进程

  CPU承担了所有的计算任务
  进程是CPU资源分配的最小单位
  在同一个时间内，单个CPU只能执行一个任务，只能运行一个进程
  如果有一个进程正在执行，其它进程就得暂停
  CPU使用了时间片轮转的算法实现多进程的调度


线程

  线程是 CPU调度的最小单位
  一个进程可以包括多个线程，这些线程共享这个进程的资源

2. chrome浏览器进程

  浏览器是多进程的
  每一个TAB页就是一个进程

  浏览器主进程
    控制其它子进程的创建和销毁
    浏览器界面显示，比如用户交互、前进、后退等操作
    将渲染的内容绘制到用户界面上

  渲染进程就是我们说的浏览器内核
    负责页面的渲染、脚本执行、事件处理
    每个TAB页都有一个渲染进程
    每个渲染进程中有主线程和合成线程等

  网络进程 处理网络请求、文件访问等操作

  GPU进程 用于3D绘制
  第三方插件进程

  3. 渲染进程

  GUI渲染线程
    渲染、布局和绘制页面
    当页面需要重绘和回流时，此线程就会执行
    与JS引擎互斥

  JS引擎线程
    负责解析执行JS脚本
    只有一个JS引擎线程(单线程)
    与GUI渲染线程互斥

  事件触发线程
    用来控制事件循环(鼠标点击、setTimeout、Ajax等)
    当事件满足触发条件时，把事件放入到JS引擎所有的执行队列中

  定时器触发线程
    setInterval和setTimeout所在线程
    定时任务并不是由JS引擎计时，而是由定时触发线程来计时的
    计时完毕后会通知事件触发线程

  异步HTTP请求线程
    浏览器有一个单独的线程处理AJAX请求
    当请求完毕后，如果有回调函数，会通知事件触发线程

  IO线程
    接收其它进程发过来的消息

4. 事件环
  单线程顺序执行 无法和外界进行交互
    (function mainThread() {
        let task1 = 1 + 2;
        let task2 = 2 + 3;
        let task3 = 3 + 4;
        console.log(task1, task2, task3);
    })()

 事件循环
    引入事件循环可以不断接收新的任务并执行
    引入输入事件可以接收用户的输入
    let readline = require('readline-sync');
    (function mainThread() {
        while (true) {
            var num1 = readline.question('num1: ');
            var num2 = readline.question('num2: ');
            let ret = eval(num1 + "+" + num2);
            console.log(ret);
        }
    })();

    4.5. 微任务
     微任务可以让新任务尽快的执行,会在主函数结束后，宏任务执行前执行

   4.6. setTimeout
    延迟队列
    定时器是不精确的
    嵌套5次以上定时器最短时间间隔设置为4ms
    未激活页面最小间隔是1000ms
    延迟最大值2147483647ms
    setTimeout中的this 会被设置为全局 window，如果是严格模式，会被设置为 undefined

  4.7.XMLHttpRequest
    XMLHttpRequest是由浏览器进程或发起请求，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中

 5.任务分类

  5.1 宏任务
    页面的大部分任务是在主任务上执行的，比如下面这些都是宏任务
    渲染事件(DOM解析、布局、绘制)
    用户交互(鼠标点击、页面缩放)
    JavaScript脚本执行
    网络请求
    文件读写
    宏任务会添加到消息到消息队列的尾部，当主线程执行到该消息的时候就会执行
    每次从事件队列中获取一个事件回调并且放到执行栈中的就是一个宏任务，宏任务执行过程中不会执行其它内容
    每次宏任务执行完毕后会进行GUI渲染线程的渲染，然后再执行下一个宏任务
    宏任务: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering
    宏任务颗粒度较大，不适合需要精确控制境的任务
    宏任务是由宿主方控制的

  5.2 微任务
    宏任务结束后会进行渲染然后执行下一个宏任务
    微任务是当前宏任务执行后立即执行的宏任务
    当宏任务执行完，就到达了检查点,会先将执行期间所产生的所有微任务都执行完再去进行渲染
    微任务是由V8引擎控制的，在创建全局执行上下文的时候，也会在V8引擎内部创建一个微任务队列
    微任务: process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver

  5.3 MutationObserver
    MutationObserver创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用
    MutationObserver采用了异步 + 微任务的方案
    异步是为了提升同步操作带来的性能问题
    微任务是为了解决实时响应的问题



