1. 进程和线程

进程

  CPU承担了所有的计算任务
  进程是CPU资源分配的最小单位
  在同一个时间内，单个CPU只能执行一个任务，只能运行一个进程
  如果有一个进程正在执行，其它进程就得暂停
  CPU使用了时间片轮转的算法实现多进程的调度


线程

  线程是 CPU调度的最小单位
  一个进程可以包括多个线程，这些线程共享这个进程的资源

2. chrome浏览器进程

  浏览器是多进程的
  每一个TAB页就是一个进程

  浏览器主进程
    控制其它子进程的创建和销毁
    浏览器界面显示，比如用户交互、前进、后退等操作
    将渲染的内容绘制到用户界面上

  渲染进程就是我们说的浏览器内核
    负责页面的渲染、脚本执行、事件处理
    每个TAB页都有一个渲染进程
    每个渲染进程中有主线程和合成线程等

  网络进程 处理网络请求、文件访问等操作

  GPU进程 用于3D绘制
  第三方插件进程

  3. 渲染进程

  GUI渲染线程
    渲染、布局和绘制页面
    当页面需要重绘和回流时，此线程就会执行
    与JS引擎互斥

  JS引擎线程
    负责解析执行JS脚本
    只有一个JS引擎线程(单线程)
    与GUI渲染线程互斥

  事件触发线程
    用来控制事件循环(鼠标点击、setTimeout、Ajax等)
    当事件满足触发条件时，把事件放入到JS引擎所有的执行队列中

  定时器触发线程
    setInterval和setTimeout所在线程
    定时任务并不是由JS引擎计时，而是由定时触发线程来计时的
    计时完毕后会通知事件触发线程

  异步HTTP请求线程
    浏览器有一个单独的线程处理AJAX请求
    当请求完毕后，如果有回调函数，会通知事件触发线程

  IO线程
    接收其它进程发过来的消息

4. 事件环
  单线程顺序执行 无法和外界进行交互
    (function mainThread() {
        let task1 = 1 + 2;
        let task2 = 2 + 3;
        let task3 = 3 + 4;
        console.log(task1, task2, task3);
    })()

 事件循环
    引入事件循环可以不断接收新的任务并执行
    引入输入事件可以接收用户的输入
    let readline = require('readline-sync');
    (function mainThread() {
        while (true) {
            var num1 = readline.question('num1: ');
            var num2 = readline.question('num2: ');
            let ret = eval(num1 + "+" + num2);
            console.log(ret);
        }
    })();

    4.5. 微任务
     微任务可以让新任务尽快的执行,会在主函数结束后，宏任务执行前执行

   4.6. setTimeout
    延迟队列
    定时器是不精确的
    嵌套5次以上定时器最短时间间隔设置为4ms
    未激活页面最小间隔是1000ms
    延迟最大值2147483647ms
    setTimeout中的this 会被设置为全局 window，如果是严格模式，会被设置为 undefined

   



